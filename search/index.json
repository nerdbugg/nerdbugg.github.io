[{"content":" # 前言 构建调试环境可以帮助程序员更好的了解程序运行时的行为，分析清楚模块间的交互关系。本文将使用QEMU+GDB的组合构建一个可以调试内核的环境，并且被调试的内核在虚拟机中可正常执行指令等操作。\n本环境搭建流程主要特点是：不依赖GUI，可在ssh会话中搭建；被调试的虚拟机包含完整发行版和系统，可安装包可执行指令。\n在此对环境搭建步骤进行记录，方面后续使用，也希望能帮到需要类似环境的同学。\n# 方案概览 在普通的用户态代码调试中，GDB进程在调用ptrace系统调用Attach至被调试进程后，由Linux内核中ptrace系统调用的实现支撑GDB读写被调试进程的内存，修改被调试进程的寄存器等操作，对用户提供断点、观察变量值这些操作。\n那么自然，在对内核的调试中，同样需要一个更高级的组件能够观察修改内核的状态，并将其提供给GDB。据笔者了解到的可选项包含QEMU模拟器提供的GDB Stub，以及Linux内核提供的KGDB两种选项。\nQEMU模拟器提供GDB Stub，由QEMU Hypervisor对虚拟机内的内核状态进行监控与修改，并通过TCP连接对外暴露服务 KGDB是Linux内核中的模块，可通过串口等方式对外暴露GDB Server服务 本文中将以QEMU+GDB方式搭建环境，KGDB方式可参考相关资料。\n# 方案步骤 # 设置虚拟机 由于笔者使用的环境为ssh会话，不提供GUI显示，以下的步骤均在该环境下进行。\n通常使用中断提供显示界面时，需要为Linux内核添加 console=ttyS0 参数，使内核向该tty设备中输出中断字节流，并由当前中断连接该设备，提供命令行界面。\n在大多数的发行版安装ISO中，内核并未配置相关参数。因此，必须借助GUI或者VNC等工具完成系统安装。\n但是，Debian发行版提供了单独的内核与ISO的安装介质，因此可以在安装过程中配置内核参数，从而可通过命令行安装系统。\n使用virt-install工具完成虚拟机操作系统安装，命令如下（参考KVM - Debian Wiki）：\n1 2 3 4 5 6 7 virt-install --virt-type kvm --name bookworm-amd64 \\ --location https://deb.debian.org/debian/dists/bookworm/main/installer-amd64/ \\ --os-variant debian12 \\ --disk size=10 --memory 1024 \\ --graphics none \\ --console pty,target_type=serial \\ --extra-args \u0026#34;console=ttyS0\u0026#34; 完成安装后，可通过 virsh start bookworm-amd64 命令启动虚拟机，使用 virtsh console bookworm-amd64 命令连接虚拟机。\n为了进一步简化操作，便于后续设置Qemu GDB参数，编写合适的qemu命令行来启动该虚拟机。一个例子如下：\n1 2 3 4 5 6 7 8 # IMAGE_PATH=path/to/vm_disk_image qemu-system-x86_64 \\ --enable-kvm \\ -m 2048 \\ -smp 2 \\ -drive file=$IMAGE_PATH,format=qcow2 \\ -netdev user,id=net0,ipv6=off,hostfwd=tcp::8022-:22 -device virtio-net-pci,netdev=net0 \\ -nographic 该例子中仅为虚拟机配置磁盘与网络两种设备，并且网络使用最简单的User-mode-Networking，配置了主机8022至虚拟机22的端口转发用于ssh登录。\n# 编译内核 在Debian发行版中， /boot 目录下会保存当前内核的config、内核、以及init ramfs。应尽可能使用相近的内核配置，避免虚拟机内配置不兼容出现问题。\n在下载对应版本内核源码后，通过上一步的ssh连接将虚拟机内的内核config拷贝下来，并打开 CONFIG_GDB_SCRIPTS 配置，关闭 CONFIG_DEBUG_INFO_REDUCED 配置。\n命令如下：\n1 2 3 # 使用12线程编译，并通过bear生成compile_commands.json便于后续IDE识别 # 由于包含了很多驱动程序模块，时间在半小时-1小时不等 bear -- make -j12 在完成编译后，得到被压缩的内核文件： ./arch/x86/boot/bzImage ，原始内核文件： ./vmlinux\n使用 sshfs 将虚拟机内的根文件目录挂载至某一文件夹下（ssh连接使用root用户），例如 ~/vm 。\n下面需要将编译好的内核模块安装至虚拟机中，命令如下：\n1 2 # ~/vm 为sshfs挂载的虚拟机根目录 make modules_install INSTALL_MOD_PATH=~/vm 最后，将内核编译使用的配置文件拷贝至虚拟机 /boot 目录下。并通过Debian中的 update-initramfs 命令根据配置生成iniframfs文件。\n1 update-initramfs -c -k 6.1.0 这里的6.1.0为内核的后缀，可在编译时的config中进行设置，内核加载目录、生成initramfs的命令行中均应保持一致。\n最后，将内核文件、initramfs拷出备用。\n# 使用编译内核启动虚拟机 最后一次使用虚拟机的原始配置登陆虚拟机，通过 cat /proc/cmdline 命令获取虚拟机内核启动参数。\n使用上一步得到的内核文件、initramfs启动虚拟机。\n1 2 3 4 5 6 7 8 9 10 qemu-system-x86_64 \\ --enable-kvm \\ -m 2048 \\ -smp 2 \\ -kernel $KERNEL_PATH \\ -initrd $INITRD_PATH \\ -append \u0026#34;root=UUID=6b911d85-9296-46bc-b71d-0facb65f92a2 rw console=ttyS0 nokaslr\u0026#34;\\ -drive file=$IMAGE_PATH,format=qcow2 \\ -netdev user,id=net0,ipv6=off,hostfwd=tcp::8022-:22 -device virtio-net-pci,netdev=net0 \\ -nographic 这里的 -append 选项即为上述得到的内核参数，在后续添加 console=ttyS0 参数来在终端访问， nokaslr 参数用来避免断点失效。\n# 配置GDB 最后，配置QEMU gdb stub选项，启动虚拟机。\n1 2 3 4 5 6 7 8 9 10 11 qemu-system-x86_64 \\ --enable-kvm \\ -m 2048 \\ -smp 2 \\ -kernel $KERNEL_PATH \\ -initrd $INITRD_PATH \\ -append \u0026#34;root=UUID=6b911d85-9296-46bc-b71d-0facb65f92a2 rw console=ttyS0 nokaslr\u0026#34;\\ -drive file=$IMAGE_PATH,format=qcow2 \\ -netdev user,id=net0,ipv6=off,hostfwd=tcp::8022-:22 -device virtio-net-pci,netdev=net0 \\ -nographic \\ -S -gdb tcp::26002 这里最后一行参数指定QEMU提供的gdb server监听26002端口，可使用gdb连接该端口进行调试。\n一个样例如下：\n1 2 # under kernel source root gdb vmlinux 1 2 # enter gdb shell (gdb) target remote :26002 完成上述步骤后，gdb在连接至gdb server后应当已经处于中断执行的状态，可通过 hbreak 指令对内核符号下断点进行调试。（使用 break 指令会提示无法访问地址）\n至此，一个纯命令行环境下的Linux内核调试环境就已经搭建好了。\n如果有GUI环境的话，为虚拟机安装操作系统的步骤会简化很多，使用Libvirt的虚拟机管理器图形界面即可。\n# 参考资料 KVM - Debian Wiki Kernel/Traditional compilation - Arch Wiki Debugging kernel and modules via gdb — The Linux Kernel documentation Booting a Custom Linux Kernel in QEMU and Debugging It With GDB Debugging the Linux kernel with GDB ","date":"2024-04-29T19:51:11+08:00","permalink":"http://nerdbugg.github.io/p/linux-kernel-debug%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","title":"Linux Kernel Debug环境搭建"},{"content":" # 起因 事情的起因是这样的：某日在用C++的特性写些小demo时，同组的同学看到我在遍历vector后，向我介绍了一个他曾经很费解的Bug。\n# 问题 我写的遍历是这样的：\n1 2 3 4 std::vector\u0026lt;int\u0026gt; vec{1,2,3,4,5}; for(int i=0;i\u0026lt;vec.size();i++) { fmt::print(\u0026#34;{} \u0026#34;, vec[i]); } 而同学的写法是这样的：\n1 2 3 4 std::vector\u0026lt;int\u0026gt; vec{1,2,3,4,5}; for(int i=0;i\u0026lt;=vec.size()-1;i++) { fmt::print(\u0026#34;{} \u0026#34;, vec[i]); } 看上去没问题，只是比较条件略做了变化，而且输出也很正常。但是，略作改动之后：\n1 2 3 4 5 std::vector\u0026lt;int\u0026gt; vec{1,2,3,4,5}; vec.clear(); // set vec size to 0 for(int i=0;i\u0026lt;=vec.size()-1;i++) { fmt::print(\u0026#34;{} \u0026#34;, vec[i]); } 这时，程序的输出就很奇怪了：在我的电脑上，本应没有输出的屏幕出现了大段的输出，并最终因为段错误而终止。而原本的写法没有问题。\n# 分析 所以，执行这段代码时究竟发生了什么？两段代码的改动仅在比较条件上，通过查询cppreference可知， vec.size() 的返回值类型为 size_type，其定义为g++内部定义的宏 __SIZE_TYPE__，再通过\n1 echo | g++ -dM -E -x c++ -|nvim - 查看g++内部定义宏可看到其类型为 long unsigned int ，也就是这里对 unsinged 的减法操作，且理论上得到的结果-1是 unsigned 无法表示的，那C标准是如 何对这个行为定义的呢？\n根据stackoverflow上的回答[1]：从C语言的语义角度理解，该算式的结果-1将会与 UINT_MAX+1进行取模，得到 UINT_MAX 。所以， 0≤UINT_MAX 的条件满足，程序根据偏移进行了非法的内存访问，并最终因为访问了无权限的内存页触发段错误终止进程。\n这段程序带来的安全隐患是切实存在的。想象一下在一个后端服务的处理函数中使用了这段程序，而栈上的变量里又存储了历史其他用户请求的数据。那么攻击者就可以构造一个使vector大小为0的输入触发该bug，进而泄漏栈上变量的值。最差的情况下，也能导致服务触发段错误进而不可用。\n# 总结 随手一写的简单代码，也有可能在意想不到的地方违背上层的语义。为了避免这样的情况发生，遵循一些常见的准则或者best practice是必要的。\n在这个例子中，我们至少应该避免对 unsigned 类型进行减法，以及避免 signed 和 unsigned 类型之间的比较。\n对于vector的使用，我们可以采取更加不易出错的遍历方法，比如range based loop或者使用迭代器进行遍历，并使用 vec.at(i) 而不是 vec[i] 避免内存越界问 题。\n1 2 3 for(auto item:vec) {item...} for(auto itr=vec.begin();itr!=vec.end();itr++) {*itr...} for(long unsinged int i=0;i\u0026lt;vec.size();i++) {vec.at(i)...} 同时，在写出上述存在内存越界问题的程序的全过程中，编译器以及Lsp没有给出任 何警告和提示，C/C++确实容易写出内存不安全的程序，尤其是语言掌握并不熟练的 人。\n但是，仍然有一些工具能够辅助程序员避免这些问题（只是语言不强制使用）\n-Wall, -Wextra提供了额外的warning，对可能存在问题的代码在编译阶段报warning Address santinizer，可以在运行时动态检查内存越界行为，在运行时报错提供信息并终止程序 [1] https://stackoverflow.com/questions/7221409/is-unsigned-integer-subtraction-defined-behavior\n[2] Range-based for loop - cppreference\n","date":"2023-05-04T14:36:07+08:00","permalink":"http://nerdbugg.github.io/p/cpp-unsigned-bug/","title":"一个vector遍历引发的惨案"},{"content":"Welcome to Hugo theme Stack. This is your first post. Edit or delete it, then start writing!\nFor more information about this theme, check the documentation: https://stack.jimmycai.com/\nWant a site like this? Check out hugo-theme-stack-stater\nPhoto by Pawel Czerwinski on Unsplash\n","date":"2022-03-06T00:00:00Z","image":"http://nerdbugg.github.io/p/hello-world/cover_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"http://nerdbugg.github.io/p/hello-world/","title":"Hello World"}]